{"pages":[],"posts":[{"title":"hexo命令","text":"关注公众号 听枫阁 获取编程资源极客算法回复111111商城项目回复222222init 123hexo init [folder]新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new 1234567891011121314151617hexo new [layout] &lt;title&gt;新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。$ hexo new &quot;post title with whitespace&quot;参数 描述-p, --path 自定义新文章的路径-r, --replace 如果存在同名文章，将其替换-s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录：hexo new page --path about/me &quot;About me&quot;以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot;注意！title 是必须指定的！如果你这么做并不能达到你的目的：hexo new page --path about/me此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 generate 12345678910111213hexo generate生成静态文件。选项 描述-d, --deploy 文件生成后立即部署网站-w, --watch 监视文件变动-b, --bail 生成过程中如果发生任何未处理的异常则抛出异常-f, --force 强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate-c, --concurrency 最大同时生成文件的数量，默认无限制该命令可以简写为hexo g publish 12hexo publish [layout] &lt;filename&gt;发表草稿。 server 1234567hexo server启动服务器。默认情况下，访问网址为： http://localhost:4000/。选项 描述-p, --port 重设端口-s, --static 只使用静态文件-l, --log 启动日记记录，使用覆盖记录格式 deploy 12345678hexo deploy部署网站。参数 描述-g, --generate 部署之前预先生成静态文件该命令可以简写为：hexo d render ````hexo render [file2] …渲染文件。 参数 描述-o, –output 设置输出路径 12migrate hexo migrate 从其他博客系统 迁移内容。 12clean hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 12list hexo list 列出网站资料。 12version hexo version显示 Hexo 版本。 123选项安全模式 hexo –safe在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 1234调试模式```hexo --debug在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式 --silent1隐藏终端信息。","link":"/2021/02/20/hexo%E5%91%BD%E4%BB%A4/"},{"title":"ArrayList和LinkedList比较","text":"关注公众号 听枫阁 获取海量编程资源 ArrayList123456 ArrayList其实是包装了一个数组 Object[]，当实例化一个ArrayList时，一个数组也被实例化，当向ArrayList中添加对象是，数组的大小也相应的改变。这样就带来以下有缺点：快速随即访问，你可以随即访问每个元素而不用考虑性能问题，通过调用get(i)方法来访问下标为i的数组元素。向其中添加对象速度慢，当你创建数组是并不能确定其容量，所以当改变这个数组时就必须在内存中做很多事情。操作其中对象的速度慢 当你要想数组中任意两个元素中间添加对象时，数组需要移动所有后面的对象。 LinkedList123456 LinkedList是通过节点直接彼此连接来实现的。每一个节点都包含前一个节点的引用，后一个节的引用和节点存储的值。当一个新节点插入时，只需要修改其中保持先后关系的节点的引用即可，当删除记录时也一样。这样就带来以下有缺点：操作其中对象的速度快 只需要改变连接，新的节点可以在内存中的任何地方不能随即访问 虽然存在get()方法，但是这个方法是通过遍历接点来定位的所以速度慢。 异同12345678910111.ArrayList底层是使用数组来实现的2.LinkedList底层是用链表来实现的3.实际开发中如果读取数据比较频繁,而插入,删除不频繁时使用ArrayList4.如果插入,删除比较频繁,使用LinkedList5.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 6.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。","link":"/2021/03/03/ArrayList%E5%92%8CLinkedList%E6%AF%94%E8%BE%83/"},{"title":"java String 三剑客","text":"关注公众号 听枫阁 获取海量编程资源 1.String、StringBuffer、StringBuilder三者的对比123String：不可变的字符序列、底层是用char型数组StringBuffer：可变的字符序列、线程安全，但效率较低；底层是用char型数组StringBuilder：可变的字符序列、线程不安全、效率较高； jdk5.0新增、底层是用char数组 2.StringBuffer与StringBuilder的内存解析(底层源码几乎一样，只是StringBuffer多了个Synchronized关键字)123456789String str = new String();//char[] value = new char[0];String str1 = new String(&quot;abc&quot;);//char[] value = new char[]{'a','b','c'};StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。System.out.println(sb1.length());//sb1.append('a');//value[0] = 'a';sb1.append('b');//value[1] = 'b';StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16]; 问题11System.out.println(sb2.length()); //3 问题212扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。 3.对比String、StringBuffer、StringBuilder三者的执行效率1从高到低排列：StringBuilder &gt; StringBuffer &gt; String 1String是固定的、不可变的。","link":"/2021/03/03/java-String-%E4%B8%89%E5%89%91%E5%AE%A2/"},{"title":"springboot+rabbitmq创建消息队列","text":"关注公众号 听枫阁 获取海量编程资源极客算法回复111111商城项目回复222222springboot+rabbitmq自动创建队列springboot+rabbitmq自动创建队列pom 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 12345678910111213spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guestproperties: #rabbitMQ消息队列 queue: insure: add: insureadd update: insureupdate del: insuredel 配置类 RabbitConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.zrf.rabbitmq.config;/** * &lt;p&gt;title: * * &lt;p&gt;Description: * * &lt;p&gt;Copyright: Copyright (c) 2004-2020 * * @author: 周润发 @version: v1.0 @date: 2021/2/23 */import lombok.Data;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;import org.springframework.amqp.rabbit.connection.ConnectionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Data@Configuration(value = &quot;rabbitConfig&quot;)public class RabbitConfig { @Value(&quot;${spring.rabbitmq.host}&quot;) private String host; @Value(&quot;${spring.rabbitmq.port}&quot;) private int port; @Value(&quot;${spring.rabbitmq.username}&quot;) private String username; @Value(&quot;${spring.rabbitmq.password}&quot;) private String password; /** * 消息队列名 */ @Value(&quot;${properties.queue.insure.add}&quot;) private String queueInsureAdd; @Value(&quot;${properties.queue.insure.update}&quot;) private String queueInsureUpdate; /** * 交换空间名称 */ public static final String EXCHANGE = &quot;microboot.exchange&quot;; /** * 设置路由key */ public static final String ROUTINGKEY = &quot;microboot.routingkey&quot;; @Bean(name = &quot;connectionFactory&quot;) public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(host, port); connectionFactory.setUsername(username); connectionFactory.setPassword(password); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setPublisherConfirms(true); return connectionFactory; } @Bean public DirectExchange exchange() { // 使用直连的模式 return new DirectExchange(EXCHANGE, true, true); } @Bean public Binding bindingAueueInsureAdd() { return BindingBuilder.bind(queueInsureAdd()).to(exchange()).with(ROUTINGKEY); } @Bean public Binding bindingQueueInsureUpdate() { return BindingBuilder.bind(queueInsureUpdate()).to(exchange()).with(ROUTINGKEY); } /** * 将需要创建的消息队列实例化 */ @Bean public Queue queueInsureAdd() { return new Queue(queueInsureAdd, true); } @Bean public Queue queueInsureUpdate() { return new Queue(queueInsureUpdate, true); }} 生产者 123456789101112131415161718192021222324252627282930313233343536package com.zrf.rabbitmq.bean;/** * &lt;p&gt;title: * * &lt;p&gt;Description: * * &lt;p&gt;Copyright: Copyright (c) 2004-2020 * * @author: 周润发 @version: v1.0 @date: 2021/2/23 */import com.zrf.rabbitmq.config.RabbitConfig;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Componentpublic class FinancingProducer { @Resource private RabbitTemplate rabbitTemplate; @Autowired private RabbitConfig rabbitConfig; public void sendMessageAdd() { rabbitTemplate.convertAndSend(rabbitConfig.getQueueInsureAdd(), &quot;financingAdd&quot;); } public void sendMessageUpdate() { } public void sendMessageDel() { }} 消费者 123456789101112131415161718192021222324252627282930313233343536package com.zrf.rabbitmq.bean;/** * &lt;p&gt;title: * * &lt;p&gt;Description: * * &lt;p&gt;Copyright: Copyright (c) 2004-2020 * * @author: 周润发 @version: v1.0 @date: 2021/2/23 */import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@Slf4jpublic class FinancingConsumer { @RabbitListener(queues = &quot;#{rabbitConfig.getQueueInsureAdd()}&quot;) public void add(String content) { log.info(&quot;financingConsumer.add():{}&quot;, content); } // @RabbitListener(queues = &quot;#{rabbitConfig.getQueueFinancingUpdate()}&quot;) public void update(String content) { log.info(&quot;financingConsumer.update():{}&quot;, content); } // @RabbitListener(queues = &quot;#{rabbitConfig.getQueueFinancingDel()}&quot;) public void del(String content) { log.info(&quot;financingConsumer.del():{}&quot;, content); }} 测试发送 123456789101112131415161718192021222324252627282930313233343536package com.zrf.rabbitmq.controller;import com.zrf.rabbitmq.bean.FinancingProducer;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * &lt;p&gt;title: * * &lt;p&gt;Description: * * &lt;p&gt;Copyright: Copyright (c) 2004-2020 * * @author: 周润发 @version: v1.0 @date: 2021/2/23 */@RestController@RequestMappingpublic class TestController { @Autowired private FinancingProducer financingProducer; /** * 测试方法 * * @return */ @GetMapping(&quot;/rabbit/testSendMsg&quot;) public String testSendMsg() { financingProducer.sendMessageAdd(); return &quot;发送成功！&quot;; }} 重新启动即可创建消息队列，发送成功后即可在rabbitmq消息队列中看到发送的消息 原文来自https://blog.csdn.net/weixin_41775418/article/details/103685820","link":"/2021/02/26/springboot-rabbitmq%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"title":"搭建个人博客","text":"使用hexo+github搭建免费个人博客详细教程关注公众号 听枫阁 获取编程资源极客算法回复111111商城项目回复2222221 准备工作 123有一个github账号，没有的话去注册一个；安装了node.js、npm，并了解相关基础知识；安装了git for windows（或者其它git客户端） 2、新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是username，那么你就新建username.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 https://username.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。几个注意的地方： 12345注册的邮箱一定要验证，否则不会成功；仓库名字必须是：username.github.io，其中username是你的用户名；仓库必须是public。仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 3、安装全局hexo 1npm install -g hexo 4、初始化hexo 12创建一个文件夹bloghexo init blog 5、生成启动服务 123cd ./bloghexo g # 生成hexo s # 启动服务 6、将代码推送到github 1234567891011如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。首先，ssh key肯定要配置好。其次，配置_config.yml中有关deploy的部分：deploy: type: git repository: https://github.com/fengyuege/fengyuege.github.io branch: master推送：npm install hexo-deployer-git --savehexo cleanhexo d 至此可以通过https://fengyuege.github.io 来访问博客了。","link":"/2021/02/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"脚本解决gitee pages无法自动更新问题","text":"关注公众号 听枫阁 获取海量编程资源puppeteer 脚本解决 gitee-page 无法自动更新因为笔者在部署自己的博客时使用github访问较慢而且文章无法被谷歌收录，然后挨个用了gitee和coding.net，发现还是gitee好用一点，但也有个很麻烦的问题，那就是使用hexo部署到gitee后，博客页面并没有更新。于是就有了这篇文章原理：使用 puppeteer 操作浏览器进行更新按钮点击。安装puppeteer123451、github下载源码，地址：https://github.com/puppeteer/puppeteer2、在项目根目录运行npm i puppeteer，npm i puppeteer-core3、根目录下新建文件giteePagesUpdate/index.js,代码放在下方4.运行js，node ./giteePagesUpdate/index.js5、亲测有效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 此处安装版本为 1.8.0const puppeteer = require('puppeteer'); async function giteeUpdate() { const browser = await puppeteer.launch({ // 此处可以使用 false 有头模式进行调试, 调试完注释即可 headless: false, }); const page = await browser.newPage(); await page.goto('https://gitee.com/login'); // 1. 选中账号控件 let accountElements = await page.$x('//*[@id=&quot;user_login&quot;]') // 此处使用 xpath 寻找控件，下同 // 2. 填入账号 await accountElements[0].type('你的 gitee 账户') // 3. 选中密码控件 let pwdElements = await page.$x('//*[@id=&quot;user_password&quot;]') // 4. 填入密码 await pwdElements[0].type('你的 gitee 密码') // 5. 点击登录 let loginButtons = await page.$x('//*[@id=&quot;new_user&quot;]/div[2]/div/div/div[4]/input') await loginButtons[0].click() // 6. 等待登录成功 await page.waitFor(1000) await page.goto('你的 gitee page 更新按钮页面'); // 比如： https://gitee.com/yang0033/hexo-blog/pages // 7.1. 监听步骤 7 中触发的确认弹框，并点击确认 await page.on('dialog', async dialog =&gt; { console.log('确认更新') dialog.accept(); }) // 7. 点击更新按钮，并弹出确认弹窗 let updateButtons = await page.$x('//*[@id=&quot;pages-branch&quot;]/div[7]') await updateButtons[0].click() // 8. 轮询并确认是否更新完毕 while (true) { await page.waitFor(2000) try { // 8.1 获取更新状态标签 deploying = await page.$x('//*[@id=&quot;pages_deploying&quot;]') if (deploying.length &gt; 0) { console.log('更新中...') } else { console.log('更新完毕') break; } } catch (error) { break; } } await page.waitFor(500); // 10.更新完毕，关闭浏览器 browser.close();}giteeUpdate();","link":"/2021/03/02/%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3gitee-pages%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"}],"tags":[],"categories":[]}